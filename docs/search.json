[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CMEP coding blog",
    "section": "",
    "text": "Mapping follow-up\n\n\n\n\n\n\ncode\n\n\nmaps\n\n\nlearning\n\n\n\n\n\n\n\n\n\nApr 21, 2025\n\n\nKim Cressman\n\n\n\n\n\n\n\n\n\n\n\n\nMapmaking\n\n\n\n\n\n\ncode\n\n\nmaps\n\n\nlearning\n\n\n\n\n\n\n\n\n\nApr 15, 2025\n\n\nKim Cressman\n\n\n\n\n\n\n\n\n\n\n\n\nKim’s first post\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nApr 15, 2025\n\n\nKim Cressman\n\n\n\n\n\n\n\n\n\n\n\n\nPost With Code\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\nApr 15, 2025\n\n\nHarlow Malloc\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nApr 12, 2025\n\n\nTristan O’Malley\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This blog is a place where personnel with Mississippi State University’s Coastal & Marine Extension Program (CMEP) can share what we learn as we code. CMEP is housed at the Coastal Research and Extension Center in Biloxi, MS."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/kims-first-post/index.html",
    "href": "posts/kims-first-post/index.html",
    "title": "Kim’s first post",
    "section": "",
    "text": "This blog is meant to allow us to share what we’ve been learning through our coding, visualization, and analysis. Currently I am learning about Quarto blogs, so this is a very boring post - I’ll be playing with formatting."
  },
  {
    "objectID": "posts/kims-first-post/index.html#header-2.1",
    "href": "posts/kims-first-post/index.html#header-2.1",
    "title": "Kim’s first post",
    "section": "Header 2.1",
    "text": "Header 2.1\nJust some throwaway text."
  },
  {
    "objectID": "posts/kims-first-post/index.html#header-2.2",
    "href": "posts/kims-first-post/index.html#header-2.2",
    "title": "Kim’s first post",
    "section": "Header 2.2",
    "text": "Header 2.2\nAnother one."
  },
  {
    "objectID": "posts/2025-04-15 Maps/index.html",
    "href": "posts/2025-04-15 Maps/index.html",
    "title": "Mapmaking",
    "section": "",
    "text": "I have been on a quest to make maps of long-term precipitation averages in the Mississippi Sound Estuary Program’s watershed. I’ve done some mapping using R, but the maps have always been … points. The last month or so is the first time I’ve actually worked with raster data - and known what ‘raster’ meant, and how spatial data like this is stored. I had an easy-ish time making a map of annual precipitation total, because there’s only one layer in the data. The complications arose when I wanted to make a faceted map, with a panel for each month.\nI know how to do this sort of thing in ggplot; in fact facets are one of the main things that led me to learn that package. But I didn’t want to turn what seemed to be a large chunk of data into a large chunk of data frames just to use what I’m familiar with. There are packages for raster data; I decided to play with them.\nBelow, I’ll go through some of the main functions I used - plot(), image(), levelplot(), and tmap(). The first two are super easy and work great with a single layer at a time. The latter two make faceting easier. Before I dig in though, some resources."
  },
  {
    "objectID": "posts/2025-04-15 Maps/index.html#precipitation",
    "href": "posts/2025-04-15 Maps/index.html#precipitation",
    "title": "Mapmaking",
    "section": "Precipitation",
    "text": "Precipitation\nI downloaded precipitation normals from the National Weather Service, as provided by the National Centers for Environmental Information. The data file is almost 275 MB so is not here in GitHub, but if you’d like to play with the same data you can get it from the Climate Normals product page. Select ‘Gridded Normals’, scroll down past a couple of maps to a table with a bunch of links, and, in the ‘1991-2020 Monthly Normals’ column, select ‘Precipitation’.\nOr copy my version out of google drive. That link goes to a folder that has the data file as well as a pdf of metadata. The data file is prcp-1991_2020-monthly-normals-v1.0.nc."
  },
  {
    "objectID": "posts/2025-04-15 Maps/index.html#watershed-boundary",
    "href": "posts/2025-04-15 Maps/index.html#watershed-boundary",
    "title": "Mapmaking",
    "section": "Watershed boundary",
    "text": "Watershed boundary\nWe will probably find a better way to share the shapefile of the MSEP boundary, but for now if you want to use it, it is in this google drive folder."
  },
  {
    "objectID": "posts/2025-04-15 Maps/index.html#loading-and-subsetting",
    "href": "posts/2025-04-15 Maps/index.html#loading-and-subsetting",
    "title": "Mapmaking",
    "section": "Loading and subsetting",
    "text": "Loading and subsetting\nTurns out there are several ways to load and work with .nc data files. I found terra::rast() kept things simplest down the line.\n\ndat_nc &lt;- rast(here::here(\"data\",\n                          \"2025-04-15 precip\",\n                          \"prcp-1991_2020-monthly-normals-v1.0.nc\"))\n\nPrinting dat_nc gives us some idea of what’s in here. Notably, there are 85 layers - you can see this in the 2nd row of output, dimensions.\n\ndat_nc\n\nclass       : SpatRaster \ndimensions  : 596, 1385, 85  (nrow, ncol, nlyr)\nresolution  : 0.04166666, 0.04166667  (x, y)\nextent      : -124.7083, -67, 24.5417, 49.37503  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (CRS84) (OGC:CRS84) \nsources     : prcp-1991_2020-monthly-normals-v1.0.nc:mlyprcp_norm  (12 layers) \n              prcp-1991_2020-monthly-normals-v1.0.nc:mlyprcp_std  (12 layers) \n              prcp-1991_2020-monthly-normals-v1.0.nc:mlyprcp_min  (12 layers) \n              ... and 12 more sources\nvarnames    : mlyprcp_norm (Monthly precipitation normals from monthly precipitation values) \n              mlyprcp_std (Standard deviation of monthly precipitation values of all input years for a given month) \n              mlyprcp_min (Minimum precipitation of monthly precipitation values of all input years for a given month) \n              ...\nnames       : mlypr~orm_1, mlypr~orm_2, mlypr~orm_3, mlypr~orm_4, mlypr~orm_5, mlypr~orm_6, ... \nunit        :  millimeter,  millimeter,  millimeter,  millimeter,  millimeter,  millimeter, ... \n\n\nI’ve set the below chunk not to evaluate, but taking a look through the names shows me that not only are there monthly normals, but also standard deviations, mins, and maxes. Additionally, we get normals, sd, min, and max for 4 different seasons, AND annual values. There are also various layers with flag in them, which I assume refers to data quality.\n\nnames(dat_nc)\n\nFrom all of this, I can make smaller datasets for only the normal (long-term average) values. I’m also assigning month abbreviations as the layer names, for nicer facet titles.\n\ndat_annual &lt;- dat_nc[[\"annprcp_norm\"]]\ndat_monthly &lt;- dat_nc[[grep(\"mlyprcp_norm\", names(dat_nc))]]\nnames(dat_monthly) &lt;- month.abb"
  },
  {
    "objectID": "posts/2025-04-15 Maps/index.html#plot-and-image",
    "href": "posts/2025-04-15 Maps/index.html#plot-and-image",
    "title": "Mapmaking",
    "section": "plot and image",
    "text": "plot and image\nAs I was working through various tutorials and options, plot() and image() kept coming up as the quickest, easiest ways to look at data. It turns out image() only shows one layer at a time, but it is great for single layers.\n\nAnnual normals\nHere is the annual data, mapped both ways. In case there was any question, we can see we are working with data from the entire country. image() uses different colors and seems like it may do more binning. It also does not have a legend by default, though one can be added.\n\nplot(dat_annual, main = \"plot()\")\n\n\n\n\n\n\n\nimage(dat_annual, main = \"image()\")\n\n\n\n\n\n\n\n\n\n\nMonthly normals\nplot() is a quick easy way to see multiple layers. Note though - color scales are different in the different facets! You have to work with it if you want the same color scale across facets. (We’ll get there in this post.)\nimage() only shows one layer at a time. I assume this is the first, and you can of course specify.\n\nplot(dat_monthly)\n\n\n\n\n\n\n\nimage(dat_monthly)\n\n\n\n\n\n\n\nimage(dat_monthly[[4]], main = \"image(), layer 4\")"
  },
  {
    "objectID": "posts/2025-04-15 Maps/index.html#convert-to-inches",
    "href": "posts/2025-04-15 Maps/index.html#convert-to-inches",
    "title": "Mapmaking",
    "section": "convert to inches",
    "text": "convert to inches\n\nannual_in &lt;- dat_annual / 25.4\nmonthly_in &lt;- dat_monthly / 25.4"
  },
  {
    "objectID": "posts/2025-04-15 Maps/index.html#get-the-ms-boundary",
    "href": "posts/2025-04-15 Maps/index.html#get-the-ms-boundary",
    "title": "Mapmaking",
    "section": "get the MS boundary",
    "text": "get the MS boundary\nIn my explorations, I also came across multiple ways to get state boundaries. USAboundaries is a useful package but didn’t play nice with all my mapping attempts - certain packages need certain explicitly spatial data types and I didn’t know how to convert what I got from USAboundaries. I’m sure it can be done. But I had also used rnaturalearth so I went back to that.\n\nms_rne &lt;- ne_states(country = \"United States of America\", returnclass = \"sf\") |&gt; \n    dplyr::filter(name == \"Mississippi\")\n\nThe spatial extent and coordinate reference system can be investigated. I don’t show the output here, only the functions.\n\next(ms_rne)\ncrs(ms_rne)\n\nAlso make sure it generally looks right:\n\nplot(st_geometry(ms_rne))\n\n\n\n\n\n\n\n\nYep, that looks like Mississippi!\nI know from all my other playing that both ms_rne and my raster files are referenced to WGS-84, but just in case, I’ll go ahead and transform.\n\nms_rne &lt;- sf::st_transform(ms_rne, crs(dat_annual))"
  },
  {
    "objectID": "posts/2025-04-15 Maps/index.html#crop-and-mask",
    "href": "posts/2025-04-15 Maps/index.html#crop-and-mask",
    "title": "Mapmaking",
    "section": "crop and mask",
    "text": "crop and mask\nGetting the raster data into the shape of MS takes two steps. crop() makes a rectangle based on the bounding box of what you’re trying to crop to, and mask() gets it into the right shape. You could also do it in the reverse order - if you use mask() first, you see colors in the shape of the state but the entire plot region still covers the entire US.\nHere, I’ll show you, because I needed to see it:\n\nplot(mask(annual_in, ms_rne), main = \"mask() only\")\n\n\n\n\n\n\n\nplot(crop(annual_in, ms_rne), main = \"crop() only\")\n\n\n\n\n\n\n\n\nSo we’ll do both! First with the annual data.\n\nannual_ms_in &lt;- crop(annual_in, ms_rne)\nannual_ms_in &lt;- mask(annual_ms_in, ms_rne)\nplot(annual_ms_in)\n\n\n\n\n\n\n\n\nAnd now with monthly:\n\nmonthly_ms_in &lt;- crop(monthly_in, ms_rne)\nmonthly_ms_in &lt;- mask(monthly_ms_in, ms_rne)\nplot(monthly_ms_in)\n\n\n\n\n\n\n\n\n\nAlso pull in MSEP boundary\nWe don’t want to crop the raster data to the MSEP boundary, but will want to overlay the boundary on the other maps. So I’ll read it in and make sure the CRS matches the other spatial files.\n\nmsep &lt;- read_sf(here::here(\"data\",\n                           \"2025-04-15 precip\",\n                           \"MSEP_outline.shp\"))\nmsep &lt;- st_transform(msep, crs(annual_ms_in))\n\n# for latticeExtra::layer and sp.polygons\nmsep_sp &lt;- as_Spatial(st_geometry(msep))\n\nNow the data’s in good shape, and it’s just about making it look nice."
  },
  {
    "objectID": "posts/2025-04-15 Maps/index.html#annual-normals-1",
    "href": "posts/2025-04-15 Maps/index.html#annual-normals-1",
    "title": "Mapmaking",
    "section": "Annual normals",
    "text": "Annual normals\nOkay, all defaults except that in levelplot() I’m setting marginal distributional plots to FALSE because they just take up too much space and aren’t meaningful here.\nAnd levelplot() doesn’t seem to want to be in a row with the others, so it gets its own panel completely.\n\n# put three plots in a row\npar(mfrow = c(1, 2))\n# make the maps\nplot(annual_ms_in, main = \"plot()\")\nimage(annual_ms_in, main = \"image()\")\n\n\n\n\n\n\n\n# go back to normal\npar(mfrow = c(1, 1))\n\n# make the levelplot\nlevelplot(annual_ms_in, margin = FALSE, main = \"levelplot()\")\n\n\n\n\n\n\n\n\n\nWith a uniform color palette and MSEP boundary\nWhen I actually looked through the help file for levelplot() (imagine that!), I found some examples of making your own theme. That simplified my code a TON. This will get re-used in the monthly plots.\n\nn_colors &lt;- 9\nmyPal &lt;- RColorBrewer::brewer.pal('GnBu', n=n_colors)\nmyTheme &lt;- rasterTheme(region = myPal)\n\n\nplot()\nThis makes a nice map, but I got tripped up on spacing and legends. I couldn’t manage to make a good legend for the MSEP boundary or figure out how to make a title for the default legend. Sounds silly, but when it ends up being easier with other packages, you just do it.\n\nplot(annual_ms_in,\n     col = myPal,\n     main = \"Average Annual Precipitation (in), 1991–2020\")\nplot(st_geometry(msep), add = TRUE, col = NA, border = \"gray20\", lwd = 2)\n\n\n\n\n\n\n\n\n\n\nimage()\nThis is probably my favorite of the annual precipitation maps.\n\nimage(annual_ms_in,\n      col = myPal,\n      main = \"Average Annual Precipitation\\n1991-2020\",\n      axes = FALSE,\n      xlim = c(-91.5, -86.5))\n# give it an outline\nbox()\n# add MSEP boundary\nplot(st_geometry(msep), add = TRUE, col = NA, border = \"gray20\", lwd = 2)\n# Add legends\n# first define the range of values\nval_range &lt;- range(values(annual_ms_in), na.rm = TRUE)\nlegend(\"topright\", \n       legend = round(seq(val_range[1], val_range[2], length.out = n_colors)),\n       fill = myPal[seq(1, n_colors, length.out = n_colors)], \n       title = \"Inches\")\nlegend(\"bottomright\",\n       legend = \"MSEP \\nBoundary\", \n       col = \"gray20\", \n       lwd = 2, \n       bty = \"n\", \n       cex = 0.8)\n\n\n\n\n\n\n\n\n\n\nlevelplot()\nI couldn’t figure out the MSEP boundary legend thing with this either, though I did manage to make a legend title and give it smaller text than the default.\nThis is where latticeExtra pops up - it’s needed to add the polygon layer.\n\nlevelplot(annual_ms_in,\n          par.settings = myTheme,\n          main = \"Average Annual Precipitation\\n1991–2020\",\n          colorkey = list(title = list(\"inches\",\n                                       fontsize = 9),\n                          space = \"right\"),\n          margin = FALSE,\n          xlab = NULL,\n          ylab = NULL,\n          scales = list(\n              x = list(draw = FALSE), \n              y = list(draw = FALSE)  \n          )\n) +\n    latticeExtra::layer(sp::sp.polygons(msep_sp))"
  },
  {
    "objectID": "posts/2025-04-15 Maps/index.html#monthly-normals-1",
    "href": "posts/2025-04-15 Maps/index.html#monthly-normals-1",
    "title": "Mapmaking",
    "section": "Monthly Normals",
    "text": "Monthly Normals\nI didn’t mess around too much before landing on a couple options that worked, so I’ll jump straight to those here.\n\nplot()\nI gave up on this function pretty quickly because an AI tool told me the zlim line should make the color scale the same in all facets, and it did NOT. I gave up before trying to add the MSEP boundary.\n\nglobal_min &lt;- min(values(monthly_ms_in), na.rm = TRUE)\nglobal_max &lt;- max(values(monthly_ms_in), na.rm = TRUE)\n\nplot(monthly_ms_in,\n     col = myPal,\n     zlim = c(global_min, global_max))\n\n\n\n\n\n\n\n\n\n\nlevelplot()\nThis worked pretty well in the end. I almost think the colors are too continuous though - it’s almost easier to see the changes when you only have a few bins and it’s all coarser. I couldn’t quite figure it out with this one, but it is pretty nice otherwise.\n\nlevelplot(monthly_ms_in,\n          par.settings = myTheme,\n          layout = c(4, 3),  # 4 columns x 3 rows\n          main = \"Average Precipitation by Month\\n1991–2020\",\n          colorkey = list(title = list(\"inches\",\n                                       fontsize = 8),\n                          space = \"bottom\"),\n          margin = FALSE,\n          xlab = NULL,\n          ylab = NULL,\n          scales = list(\n              x = list(draw = FALSE),  \n              y = list(draw = FALSE)   \n          )\n) +\n    latticeExtra::layer(sp::sp.polygons(msep_sp))\n\n\n\n\n\n\n\n\n\n\ntmap\nThe tmap package lets you make both static and interactive maps (fun!). Here we set the mode to plot to be static, and then add layers in a similar way to how ggplot2 works. It was really quite simple to get here using tmap - I had a much easier time than I did with levelplot() and this will probably be my go-to in the future.\nAs with levelplot(), I would prefer a coarser binning of values, but that’s probably doable with more time. And as with most of the others, I haven’t figured out how to add a legend saying that the line in the middle of the state is the MSEP boundary. Again, I’m sure it’s possible and I just need to put more time in.\nI’d still like to tinker on smaller things too - for example, making the facet labels have a white background. I suspect that’s pretty easy, but I’m sort of at the end of my brainpower here, so this is good enough for now.\n\ntmap_mode(\"plot\")\n\n# start with the raster data and layer\ntm_shape(monthly_ms_in) +\n    tm_raster(col.scale = tm_scale_continuous(values = \"brewer.gn_bu\"),\n              col.free = FALSE,  # make the colors the same in every facet\n              col.legend = tm_legend(title = \"Inches\",\n                                     position = tm_pos_out(\"right\"))) +\n    # add the MSEP boundary\n    tm_shape(msep) +\n    tm_borders(col = \"black\", lwd = 2) +\n    # change the layout\n    tm_facets(ncol = 4, nrow = 3) +\n    tm_title(\"Average Precipitation by Month\\n1991–2020\")"
  },
  {
    "objectID": "about.html#about-this-blog",
    "href": "about.html#about-this-blog",
    "title": "About",
    "section": "",
    "text": "This blog is a place where personnel with Mississippi State University’s Coastal & Marine Extension Program (CMEP) can share what we learn as we code. CMEP is housed at the Coastal Research and Extension Center in Biloxi, MS."
  },
  {
    "objectID": "posts/2025-04-21_map_followup/index.html",
    "href": "posts/2025-04-21_map_followup/index.html",
    "title": "Mapping follow-up",
    "section": "",
    "text": "Within 2 days of my first post here, where I struggled with maps and avoided using ggplot2 because I thought I had to turn my raster data into data frames first (thanks, chatGPT), I saw a post on LinkedIn about the tidyterra package. The link to the specific post doesn’t seem to work when I’m not logged in, but credit to Joachim Stork for talking about this package, which integrates terra with ggplot2.\nI made a new faceted map, with labels everywhere I wanted them, within 20 minutes. I still want to figure out how to do a coarse binning of values, but I got a generally equivalent plot to the other packages, with all the labeling I wanted. I will note I’ve worked with ggplot2 for so long that some of the theming that was simple for me would not have been simple if I was coming to this from scratch - so it’s not necessarily that ggplot2 is better than the others; it’s just that I know it so it’s better for me.\nLoad the packages; read and trim the data the same way as before.\n\nlibrary(terra)\nlibrary(rnaturalearth)\nlibrary(sf)\nlibrary(RColorBrewer)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyterra)\n\n\n# precip data ----\ndat_nc &lt;- rast(here::here(\"data\",\n                          \"2025-04-15 precip\",\n                          \"prcp-1991_2020-monthly-normals-v1.0.nc\"))\n\ndat_monthly &lt;- dat_nc[[grep(\"mlyprcp_norm\", names(dat_nc))]]\nnames(dat_monthly) &lt;- month.abb\n\n# convert to inches\nmonthly_in &lt;- dat_monthly / 25.4\n\n# crop to MS ----\n# ms from rnaturalearth\nms_rne &lt;- ne_states(country = \"United States of America\", returnclass = \"sf\") |&gt; \n    dplyr::filter(name == \"Mississippi\")\nms_rne &lt;- sf::st_transform(ms_rne, crs(dat_monthly))\n\nmonthly_ms_in &lt;- crop(monthly_in, ms_rne)\nmonthly_ms_in &lt;- mask(monthly_ms_in, ms_rne)\n\n\n# msep outline ----\nmsep &lt;- read_sf(here::here(\"data\",\n                           \"2025-04-15 precip\",\n                           \"MSEP_outline.shp\"))\nmsep &lt;- st_transform(msep, crs(monthly_ms_in))\n\nI made the faceted plot with tidyterra::geom_spatraster() and facet_wrap(~lyr). It was super easy; and then I used scale_fill_distiller() to get my favorite palette from RColorBrewer.\n\np &lt;- ggplot() +\n    geom_spatraster(data = monthly_ms_in) +\n    facet_wrap(~lyr) +\n    scale_fill_distiller(palette = \"GnBu\", direction = 1,\n                         na.value = NA) +\n    theme_minimal() +\n    theme(axis.text = element_blank(),\n          axis.ticks = element_blank(),\n          strip.background = element_rect(fill = NA,\n                                          color = NA),\n          strip.text = element_text(face = \"bold\")) +\n    labs(title = \"Monthly Precipitation Normals\",\n         subtitle = \"1991-2020 average\",\n         fill = \"Inches\")\n\np\n\n\n\n\n\n\n\n\nI’ve been removing axis text and tick marks a lot lately using theme(), but if you’re not familiar with all the options, check out the ggThemeAssist package. It provides a point-and-click interface to spruce up your plots once you have a general one made, and returns the code to you.\nOnce I had the general plot worked out, I added the MSEP’s boundary. This is where things got a little tricky for me, because I wanted the line to show up as a legend - so I used aes() inside geom_sf() and then forced the color to be how I wanted it with scale_color_manual(). Then I had to use labs() to make sure there wasn’t a title for that piece of the legend.\nI wasn’t sure if using \\n as a line break would actually work this way, but it did!\nI had read in the layer with the sf package, so I used geom_sf() from ggplot2 at first.\n\np +\n    geom_sf(data = msep,\n                    fill = NA,\n                    linewidth = 0.7,\n                    aes(col = \"MSEP \\nboundary\"),\n                    show.legend = \"line\") +\n    scale_color_manual(values = c(\"MSEP \\nboundary\" = \"gray20\")) +\n    labs(col = NULL)\n\n\n\n\n\n\n\n\nAs I was putting this post together, I noticed that not only does tidyterra provide geom_spatraster(), but also geom_spatvector() - so I use that below. It comes out the same - which probably means I can use terra for all the data import? But I’ll save that exploration for another time.\n\np +\n    geom_spatvector(data = msep,\n                    fill = NA,\n                    linewidth = 0.7,\n                    aes(col = \"MSEP \\nboundary\"),\n                    show.legend = \"line\") +\n    scale_color_manual(values = c(\"MSEP \\nboundary\" = \"gray20\")) +\n    labs(col = NULL)\n\n\n\n\n\n\n\n\nThat’s all for today - happy mapping!"
  }
]